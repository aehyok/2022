import{_ as e,o as a,c as t,b as i}from"./app.39978e14.js";const u=JSON.parse('{"title":"openai 近两个月更新内容实践","description":"","frontmatter":{},"headers":[{"level":2,"title":"下周7月24日到7月29日左右","slug":"下周7月24日到7月29日左右","link":"#下周7月24日到7月29日左右","children":[]},{"level":2,"title":"前言","slug":"前言","link":"#前言","children":[]},{"level":2,"title":"实例","slug":"实例","link":"#实例","children":[]},{"level":2,"title":"访问次数的限制","slug":"访问次数的限制","link":"#访问次数的限制","children":[]}],"relativePath":"javascript/2023-07-21-openai.md","lastUpdated":1709465121000}'),r={name:"javascript/2023-07-21-openai.md"},n=i('<h1 id="openai-近两个月更新内容实践" tabindex="-1">openai 近两个月更新内容实践 <a class="header-anchor" href="#openai-近两个月更新内容实践" aria-hidden="true">#</a></h1><ul><li><p><a href="https://zhuanlan.zhihu.com/p/637107426" target="_blank" rel="noreferrer">https://zhuanlan.zhihu.com/p/637107426</a></p></li><li><p>降价对我来说是无所谓的事情，都要使用，而且毕竟也便宜了。</p></li><li><p>分享功能</p></li><li><p>code-interpreter 插件</p></li></ul><h2 id="下周7月24日到7月29日左右" tabindex="-1">下周7月24日到7月29日左右 <a class="header-anchor" href="#下周7月24日到7月29日左右" aria-hidden="true">#</a></h2><p>ChatGPT PLUS 用户GPT-4模型每三小时25条的限制，将提升到50条。</p><h1 id="chatgpt-api-支持函数调用功能-相当于结构化输出json-真的太好用了" tabindex="-1">ChatGPT API 支持函数调用功能（相当于结构化输出json），真的太好用了 <a class="header-anchor" href="#chatgpt-api-支持函数调用功能-相当于结构化输出json-真的太好用了" aria-hidden="true">#</a></h1><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-hidden="true">#</a></h2><p>开始的一段时间，如果你想通过ChatGPT 的API来定制化一些工作，可能要反复的调整prompt，来使ChatGPT API接口能够返回json结构化的数据。但有时候可能又会存在一些问题。 或者通过直接对返回的长字符串进行正则匹配的模式来处理，但是这种方式也是非常的糟糕，而且有一些情况下也是正则无法处理的，而且我对正则的了解仅仅限于拿来就用。</p><p>盼星星，盼月亮，OpenAI 团队终于在6月14日左右的时候，通过函数调用的方式支持了结构化的输出JSON。这样有了结构化的数据，就可以很方便的与自定义函数和业务逻辑进行整合处理。</p><p>开发者现在可以描述函数给 gpt-4-0613 和 gpt-3.5-turbo-0613两个模型，并使模型智能地选择输出一个包含调用这些函数的参数的 JSON 对象。这样就可以将 GPT 的功能与外部工具和 API 很丝滑的就联结起来了。</p><h2 id="实例" tabindex="-1">实例 <a class="header-anchor" href="#实例" aria-hidden="true">#</a></h2><p>通过官网的ChatGPT 先来查看效果。</p><h2 id="访问次数的限制" tabindex="-1">访问次数的限制 <a class="header-anchor" href="#访问次数的限制" aria-hidden="true">#</a></h2><p>TPM 和 RPM 在应用开发接口访问次数的限制上通常代表以下意思：</p><p>TPM: Transactions Per Minute。这个指标用来度量每分钟允许的事务数或者请求数。如果一项服务的 TPM 限制是 1000，那么你在一分钟内发送到该服务的请求不能超过 1000 次。</p><p>RPM: Requests Per Minute。这个指标类似于 TPM，但它通常用来度量 HTTP 请求。如果一项服务的 RPM 限制是 500，那么你在一分钟内发送到该服务的 HTTP 请求不能超过 500 次。</p><p>需要注意的是，不同的服务可能会有不同的定义或者对同一种类型的请求有不同的计数规则。因此在使用一个服务时，应当查阅其官方文档以确保理解其限制的具体含义。</p>',16),h=[n];function p(l,s,d,o,c,_){return a(),t("div",null,h)}const T=e(r,[["render",p]]);export{u as __pageData,T as default};
